---
title: "Differential EXpression Downstream Analysis SHiny app"
package: dexdash
output: rmarkdown::html_vignette
abstract: |
    This R package is designed for interactive exploration and analysis
    of differential expression (DE) results. It combines Shiny-based
    visualization tools with rapid functional enrichment analysis. Users
    can select genes from a volcano or MA plot to find their names,
    descriptions and plot expression patterns. The build-in fast functional
    enrichment (based on `fenr` package) allows to see instantly which
    biological pathways and processes those genes are involved in, based on
    enrichment analysis of Gene Ontology (GO), KEGG, and Reactome databases.
    The input for the app consists of five data frames containing DE results,
    expression or abundance data, experimental design, gene names and descriptions.
    A build-in function allowes for easy downloading of functional term data.
    Once started, the app is fast and easy to use.
vignette: >
  %\VignetteIndexEntry{Differential EXpression Downstream Analysis SHiny app}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r, include = FALSE}
options(width = 72)
library(tibble)
library(dplyr)
library(tidyr)
library(forcats)
library(stringr)
library(edgeR)
library(gt)
```

```{r setup}
library(dexdash)
```

## Overview

Imagine you've carried out an RNA-seq experiment, a proteomics study, or maybe another type of -omics research. You've done read mapping or protein quantifications and now have a set of data in hand. This data captures expression or abundance (we will call it 'expression' for simplicity) for each gene, protein, or other entity (hereinafter referred to as 'feature'). These expressions are recorded across various biological conditions (which we'll call 'groups') and their replicates. Following this, you've conducted a differential expression analysis using tools like *limma*, *edgeR*, *DESeq2*, or similar, ending up with a data frame that includes log-fold change, p-value, among other metrics.

Now, you're ready to investigate the results. You want to generate a volcano or MA plot, quickly identify features of interest, and explore the functional similarities among groups of features that behave similarly. This is exactly what *dexdash* is for. Simply feed it your expression data, differential expression results, and some details about your experimental design and gene names, and voila! You're equipped with a web-based interactive tool to explore your data.


```{r figure, fig.cap="Screenshot of dexdash Shiny app.", echo=FALSE, out.width="100%"}
knitr::include_graphics("figures/screenshot.png")
```

## Installation

*dexdash* can be installed from *GitHub* by using:

```{r bioconductor_install, eval = FALSE}
if (!require("remotes", quietly = TRUE))
  install.packages("remotes")

remotes::install_github("bartongroup/dexdash")
```

## Quick example

```{r quick_example, eval = FALSE}
library(dexdash)

# Data examples available in the package
data(yeast_de, yeast_data, yeast_metadata, yeast_features)
# The slow bit: download functional term data
fterms <- download_functional_terms("yeast", feature_name = "gene_id")
# The fast bit: interactive app
run_app(yeast_de, yeast_data, yeast_metadata, yeast_features, fterms)
```

## Usage

```{r prepare_table, echo = FALSE}
args_de <- tibble::tribble(
  ~column, ~type, ~description,
  "id", "character", "feature identifier",
  "log_fc", "numeric", "log-fold change; use <span style='font-family: monospace'>logFC</span> from *edgeR* and *limma*, <span style='font-family: monospace'>log2FoldChange</span> from *DESeq2*",
  "expr", "numeric",  "mean expression or abundance, typically in logarithmic scale; use <span style='font-family: monospace'>logCPM</span> from *edgeR*, <span style='font-family: monospace'>log10(baseMean)</span> from *DESeq2*, <span style='font-family: monospace'>AveExpr</span> from *limma*",
  "p_value", "numeric", "p-value from statistical tests; use <span style='font-family: monospace'>PValue</span> from *edgeR* and *limma*, <span style='font-family: monospace'>pvalue</span> from *DESeq2*",
  "contrast", "factor", "name of the contrast; this data frame can contain results from multiple contrast"
) |> 
  tibble::add_column(argument = c("de", "", "", "", ""), .before = 1)

args_data <- tibble::tribble(
  ~column, ~type, ~description,
  "id", "character", "feature identifier",
  "sample", "character", "sample identifer",
  "value", "numeric", "the expression, or abundance of the gene/protein for this sample"
) |> 
  tibble::add_column(argument = c("data", "", ""), .before = 1)

args_metadata <- tibble::tribble(
  ~column, ~type, ~description,
  "sample", "character", "sample identifer",
  "group",  "character/factor", "a grouping variable, for example condition or treatment"
) |> 
  tibble::add_column(argument = c("metadata", ""), .before = 1)

args_features <- tibble::tribble(
  ~column, ~type, ~description,
  "id", "character", "feature identifier",
  "name", "character", "a human-readable name of the feature, typically a gene symbol",
  "decription", "character", "a brief description of the feature"
) |> 
  tibble::add_column(argument = c("features", "", ""), .before = 1)

all_args <- bind_rows(args_de, args_data, args_metadata, args_features)
```

The *dexdash* Shiny app is launched with a command:

```{r usage, eval = FALSE}
run_app(de, data, metadata, features, fterms)
```

There are five mandatory arguments:

  - `de` - data frame with differential expression results,
  - `data` - data frame with expression or abundance data,
  - `metadata` - data frame with the design of the experiment,
  - `features` - data frame with feature names and descriptions,
  - `fterms` - an object containing functional terms data.


## Data frames

The table below summarises columns required in the four data frames. These data frames must be created by the user. Differential expression output differs from tool to tool, here we show which columns to use from the output of *edgeR*, *DESeq2* and *limma*. A full worked example below demonstrates how to prepare the required data, step by step.


```{r data_frame_columns, echo = FALSE, results = 'asis', eval=FALSE}
all_args |> 
  group_by(argument) |> 
  gt() |> 
   tab_style(
    style = cell_fill(color = "bisque"),
    locations = cells_row_groups()
  ) |> 
  as_raw_html()
```


```{r data_columns, echo = FALSE}
knitr::kable(all_args)
```

## Functional term data

To perform fast interactive functional enrichment, *dexdash* requires data downloaded from on-line databases and prepared for fast enrichment. This can be achieved with the following function:

```{r download_terms, eval = FALSE}
fterms <- download_functional_terms(species = "yeast", feature_name = "gene_id")
```

The first argument in this function is a species name. Based on this name, the function will downlad the relevant data from the online databases. The GO, KEGG and Reactome databases use different species designation names. For example, designation for yeast is "sgd", "Saccharomyces cerevisiae" and "sce", for GO, Reactome and KEGG, respectively. In oder to interrogate these databases, the correct designations must be passed on. This package contains a small JSON file, which can be accessed:

```{r species_file}
species_file <- system.file("extdata", "species.json", package = "dexdash")
```

Here is the content of the file:

```{r species_json, results="asis", echo = FALSE}
cat("<pre>")
readLines(species_file) |> cat(sep = "\n")
cat("</pre>")
```

It contains designation information for a few species. If your species is not included, you need to create a JSON file in the same format, as the included file, and provide its location by argument `species_file` in the `download_functional_terms()` function. The species designations can be found using `fenr::fetch_go_species()`, `fenr::fetch_reactome_species()` and `fenr::fetch_kegg_species()`. These three functions return data frames,
where column `designation` contains the species designation required.

The second argument, `feature_name`, specifies the name of the column in the `mapping` tibble to be used as the feature identifier. See the [vignette](https://bioconductor.org/packages/release/bioc/vignettes/fenr/inst/doc/fenr.html) of `fenr` package for more details. `feature_name` can be either `"gene_symbol"` or `"gene_id"`. If
your data contain gene symbols (e.g. `"BRCA1"` or `"FOXP1"`), use `feature_name = "gene_symbol"`. If your data contain Ensembl identifiers (e.g. `"ENSG00000012048"` or  `"ENSG00000114861"`), use `feature_name = "gene_id"`.


# Worked example

## Count data

We start with the count data from an RNA-seq experiment. Let's call it `mtx`. It is a matrix with rows corresponding to genes and columns corresponding to samples. It contains the same data as the `yeast_data` object, but in wide, matrix format.

```{r count_matrix}
data(mtx)
dim(mtx)
head(mtx)
```

## Metadata

First, we create a metadata data frame with grouping information. We extract group designation (WT or Snf2) form sample names and convert them into factors, with the first level `WT`. As per *dexdash* requirements, the column names of this data frame are `sample` and `group`:

```{r metadata}
library(tibble)
library(dplyr)
library(tidyr)
library(forcats)

metadata <- tibble(sample = colnames(mtx)) |> 
  mutate(group = str_extract(sample, "^.+(?=-)")) |> 
  mutate(group = fct_relevel(group, "WT"))

metadata
```

## Differential expression

Next, we carry out differential expression using *edgeR*. This is a simple case of two conditions (groups), each in six replicates. Again, we need specific column names for *dexdash*. If you use a different differential expression tool, the default column names would be different. In any case, they need to be `id`, `log_fc`, `expr`, `p_value`, and `contrast`. Whichever DE tool you use, make sure to rename the columns before passing the result to `dexdash`.

```{r differential_expression}
library(edgeR)
library(purrr)

design_mat <- model.matrix(~group, metadata)
de <- mtx |> 
  DGEList() |>
  calcNormFactors() |>
  estimateDisp(design = design_mat) |>
  glmQLFit(design = design_mat) |>
  glmQLFTest(coef = "groupSnf2") |>
  topTags(n = 1e16, sort.by = "none") |>
  pluck("table") |>
  as_tibble(rownames = "id") |>
  add_column(contrast = "Snf2-WT") |> 
  rename(
    log_fc = logFC,
    expr = logCPM,
    p_value = PValue
  )

de
```

## Count data in the long format

`dexdash` requires count data in the long format, with column names `id`, `sample` and `value`. We create the appropriate data frame:

```{r long_format}
data <- mtx |> 
  as_tibble(rownames = "id") |> 
  pivot_longer(-id, names_to = "sample", values_to = "value")

data
```

## Feature names and descriptions

Next, we need a table converting cryptic gene identifiers into human-readable gene names. We use `biomaRt` for this purpose. Below, we shorten gene descriptions by removing everything after the semicolon (extended desctiption) and/or after bracket `[`, which contains species name.

```{r get_features, include = FALSE}
features = yeast_features
```


```{r biomart, eval = FALSE}
library(biomaRt)
library(stringr)

mart <- useEnsembl(biomart = "ensembl", dataset = "scerevisiae_gene_ensembl")
attr <- c(
  id = "ensembl_gene_id",
  name = "external_gene_name",
  description = "description"
)

features <- getBM(attributes = attr, mart = mart, useCache = TRUE) |> 
  as_tibble() |> 
  rename(!!attr) |> 
  mutate(
      description = str_remove(description, "(;|\\s\\[).+$"),
      name = na_if(name, "")
    ) |> 
  mutate(name = if_else(is.na(name), id, name))
```

The resulting data frame is

```{r features_table}
features
```

## Functional enrichment data

Finally, as indicated earlier, we need the functional enrichment data:

```{r download_terms_2, eval = FALSE}
fterms <- download_functional_terms("yeast", feature_name = "gene_id")
```

## Run dexdash

Now, we have all necessary data to launch `dexdash`:

```{r run_app, eval = FALSE}
run_app(de, data, metadata, features, fterms)
```


# Session info {.unnumbered}

```{r session_info, echo = FALSE}
sessionInfo()
```
