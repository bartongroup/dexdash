---
title: "Differential EXpression Downstream Analysis SHiny app"
package: dexdash
output: rmarkdown::html_vignette
abstract: |
    This R package is designed for interactive exploration and analysis
    of differential expression (DE) results. It combines Shiny-based
    visualization tools with rapid functional enrichment analysis. Users
    can select genes from a volcano or MA plot to find their names,
    descriptions and plot expression patterns. The build-in fast functional
    enrichment (based on `fenr` package) allows to see instantly which
    biological pathways and processes those genes are involved in, based on
    enrichment analysis of Gene Ontology (GO), KEGG, and Reactome databases.
    The input for the app consists of five data frames containing DE results,
    expression or abundance data, experimental design, gene names and descriptions.
    A build-in function allowes for easy downloading of functional term data.
    Once started, the app is fast and easy to use.
vignette: >
  %\VignetteIndexEntry{Differential expression downstream analysis shiny app}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
options(width = 72)
library(tibble)
```

```{r setup}
library(dexdash)
```

# Where does dexdash come in?

Imagine you've carried out an RNA-seq experiment, a proteomics study, or maybe another type of -omics research. You've tackled read mapping or protein quantifications and now have a set of data in hand. This data captures expression or abundance (we will call it 'expression' for simplicity) for each gene, protein, or other entity (hereinafter referred to as 'feature'). These expressions are recorded across various biological conditions (which we'll call 'groups') and their replicates. Following this, you've conducted a differential expression analysis using tools like *limma*, *edgeR*, *DESeq2*, or similar, ending up with a data frame that includes log-fold change, p-value, among other metrics.

Now, you're ready to dive into the results. You want to generate a volcano or MA plot, quickly identify features of interest, and explore the functional similarities among groups of features that behave similarly. This is where *dexdash* shines. Simply feed it your expression data, differential expression results, and some details about your experimental design and gene names, and voila! You're equipped with a web-based interactive tool to sift through your data.


```{r figure, fig.cap="Screenshot of dexdash Shiny app.", echo=FALSE, out.width="700px"}
knitr::include_graphics("figures/screenshot.png")
```

# Installation

*dexdash* can be installed from *GitHub* by using:

```{r bioconductor_install, eval=FALSE}
if (!require("remotes", quietly = TRUE))
  install.packages("remotes")

remotes::install_github("bartongroup/dexdash")
```

# Quick example

```{r, eval=FALSE}
# Data examples available in the package
data(yeast_de, yeast_data, yeast_metadata, yeast_features)
# The slow bit: download functional term data
fterms <- download_functional_terms("yeast", feature_name = "gene_id")
# The fast bit: interactive app
run_app(yeast_de, yeast_data, yeast_metadata, yeast_features, fterms)
```

# Required input data

The input data for *dexdash* consists of 5 objects: `de`, `data`, `metadata`, `features` and `fterms`.

## Differential expression results

Argument name `de`. This is a data frame (or tibble) containing results of differential expression/abundance, per feature. It should have the following columns:

  - `id` (character) - feature identifier,
  - `log_fc` (numeric) - log-fold change,
  - `expr` (numeric) - mean expression or abundance,
  - `p_value` (numeric) - p-value from statistical tests,
  - `fdr` (numeric) - false discovery rate, p-value corrected for multiple tests,
  - `contrast` (factor) - name of the contrast; this data frame can contain results from multiple contrasts.
  
Here is an example of differential expression data, included in this package:

```{r}
data(yeast_de)
yeast_de
```

## Expression data

Argument name `data`. This is a data frame containing expression/abundance data, per sample, per feature. It should have the following columns:

 - `id` (character) - feature identifier, the same as in `de` data frame,
 - `sample` (character) - sample identifier,
 - `value` (numeric) - the expression, or abundance of the gene/protein for this sample.
 
Here is an example of expression data, included in this package:

```{r}
data(yeast_data)
yeast_data
```

## Design of the experiment
 
Argument name `metadata`. It contains the design of the experiment. It should have the following columns:
 
  - `sample` (character) - sample identifier, the same as in `data` data frame,
  - `group` (character/factor) - a grouping variable, for example condition or treatment,
  - `replicate` - optional replicate ID.

Here is an example of metadata, included in this package:

```{r}
data(yeast_metadata)
yeast_metadata
```

## Feature information

Argument name `features`. It contains alternative names for features (e.g. gene symbols) an descriptions. It should have the following columns:

 - `id` (character) - feature identifier, the same as in `de` and `data` frames,
 - `name` (character) - a human-readable name of the feature, typically a gene symbol,
 - `decription` (character) - a brief description of the feature.


Here is an example of feature information, included in this package:

```{r}
data(yeast_features)
yeast_features
```

## Functional term data

To perform fast interactive functional enrichment, the Shiny app requires data downloaded from online databases and prepared for fast enrichment. This can be achieved with the following function:

```{r, eval=FALSE}
fterms <- download_functional_terms(species = "yeast", feature_name = "gene_id")
```


The first argument in this function is a species name. Based on this name, the function will downlad the relevant data from the online databases. The GO, KEGG and Reactome databases use different species designation names. For example, designation for yeast is "sgd", "Saccharomyces cerevisiae" and "sce", for GO, Reactome and KEGG, respectively. In oder to interrogate these databases, the correct designations must be passed on. This package contains a small JSON file, which can be accessed:

```{r}
species_file <- system.file("extdata", "species.json", package = "dexdash")
```

Here is the content of the file:

```{r, results="asis", echo=FALSE}
cat("<pre>")
readLines(species_file) |> cat(sep = "\n")
cat("</pre>")
```

It contains designation information for a few species. If your species is not included, you need to create a JSON file in the same format, as the included file, and provide its location by argument `species_file` in the `download_functional_terms()` function. The species designations can be found using `fenr::fetch_go_species()`, `fenr::fetch_reactome_species()` and `fenr::fetch_kegg_species()`. These three functions return data frames,
where column `designation` contains the species designation required.

# Session info {.unnumbered}

```{r session_info, echo=FALSE}
sessionInfo()
```
